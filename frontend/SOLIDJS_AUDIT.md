# SolidJS Anti-Pattern Audit

| # | Severity | File | Lines | Issue |
|---|----------|------|-------|-------|
| 1 | **Critical** | `AgentDock.tsx` | 163–166 | `sessionReady()` is read without `untrack` inside the stream-setup effect, so the effect re-runs — and tears down and re-opens the SSE stream — every time the session finishes loading, not only when the session ID changes. |
| 2 | **Critical** | `SessionTranscript.tsx` | 79, 81–86 | `const { message } = props` destructures the SolidJS props proxy, capturing a snapshot of the values at first render. Fields like `message.open`, `message.kind`, `message.content`, and derived values (`blocks`, `isLong`, `kindLabel`) are frozen and will not update when the parent calls `mergeMessages` with a revised entry. |
| 3 | **Critical** | `SessionTerminals.tsx` | 43–46 | Same props-destructuring bug: `const { terminal } = props` freezes `terminal.terminal_kind` and the derived `label` at first render. |
| 4 | **Critical** | `useAgentDockMcp.ts` | 40–41, 53–55 | An `AbortController` is created and aborted in `onCleanup`, but its `signal` is never passed to `pollDockMcp` or the underlying `fetch`. The cleanup call is a no-op, so the in-flight 20-second long-poll hangs until it naturally times out after the component unmounts. Additionally, when the backend returns 404 (stale or non-dock session ID), the catch block waits 1 second and then retries forever; the stale `dockSessionId` should be cleared and polling stopped on 404. |
| 5 | **Critical** | `routes/extractors.tsx` | 603 | `sessions()?.sessions` is called on a `Signal<SessionResponse[]>` — `sessions()` already returns the array, so `.sessions` is always `undefined`. The `For` loop iterates an empty list and no sessions are ever shown in the extractor session picker. |
| 6 | **High** | `routes/tasks.tsx` | 83–87 | `treeData` is a `createSignal` driven by a `createEffect` that copies from `treeResponse()`. This derived-state-as-signal pattern means `treeData` is one reactive tick stale on first load, so every consumer (`filteredTree`, `graphData`, `roles`, `selectedTask`, `countTasks`) receives an empty array on the initial render instead of the already-resolved data. |
| 7 | **High** | `routes/extractors.tsx` | 72–85 | The rule-selection effect both reads and writes `selectedRuleId()`. Because `selectedRuleId` is tracked as a dependency, each write causes the effect to re-run a second time. Wrapping the read in `untrack` removes the spurious dependency and eliminates the double-run. |
| 8 | **High** | `routes/extractors.tsx` | 37–48 | The `initialized` guard in the config-loading effect prevents the draft from being updated after the user calls `refetch()`. Once `initialized` is `true`, any subsequent resource reload is silently ignored and the UI shows stale config. |
| 9 | **Medium** | `state/sessions.ts` | 84 | `onCleanup` is called inside `subscribe()`, a plain function. This works only because `subscribe` happens to be invoked during component initialization (inside a reactive owner). If `useSessionStore` is ever called outside a component — in a test, a module-level effect, or a timeout — `onCleanup` is silently ignored and the 15-second polling interval is never cleared. |
| 10 | **Medium** | `state/terminals.ts` | 77 | Same fragile `onCleanup`-inside-plain-function pattern as `state/sessions.ts`. |
| 11 | **Medium** | `SessionTranscript.tsx` | 68–71 | `<For>` uses referential equality to key items. `mergeMessages` always produces a new object for updated entries (`{ ...existing, ...next }`), so `For` treats each update as a removal + insertion, unmounting and remounting the `TranscriptItem`. This resets the per-item `expanded` signal to `false` and causes unnecessary DOM churn for messages that are still streaming in. |
| 12 | **Medium** | `routes/tasks.tsx` | 130–138 | The selected-task effect reads `sessionInfo()` without `untrack`, making it a tracked dependency. When the effect writes `setSessionInfo(null)`, it re-triggers itself immediately. SolidJS cycle detection stops it after one extra pass, but the double-run is avoidable with `untrack(sessionInfo)`. |
| 13 | **Low** | `SessionComposer.tsx` | 33–39 | A `createEffect` is used for a one-time initialization of `selectedProviderId`. The effect reads `selectedProviderId()` as its gate condition, making that signal a tracked dependency. `onMount` is the correct primitive for one-time imperative setup and makes the intent unambiguous. |
| 14 | **Low** | `routes/sessions/$sessionId.tsx` | 87–91 | A `createEffect` overwrites `sessionStateOverride` with the resource value every time `session()` resolves. Because `status_change` SSE events also trigger a `refetchSession`, the state set optimistically from the stream is immediately overwritten by the resource — causing a visible flicker even when both values are identical. |
| 15 | **Critical** | `hooks/useSessionTranscript.ts` | 199–225 | `loadActivityHistory` is an async function called from `createEffect`. The `setActivityHistoryLoading(false)` call in the `finally` block executes after an `await`, outside any reactive batch, and re-triggers effects that track `activityHistoryLoading`. This creates an infinite reactive recursion that spams `/api/sessions/.../activity` at full speed. Fix: replace the manual signal + async-effect pattern with `createResource`, which manages fetching, loading, and error state safely within the reactive graph. |
| 16 | **Medium** | `routes/sessions/$sessionId.tsx` | 94–140 | The stream-setup `createEffect` reads `permissions.loading` and `canInspect()` (which reads `permissions()`). If the permissions resource ever refetches — even transiently — the effect re-runs, closing and reopening the SSE stream mid-session. These dependencies should be consumed via `untrack` or the stream should be guarded by a stable `createMemo` that only changes when the session ID changes. |
